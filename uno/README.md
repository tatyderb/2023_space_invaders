# Правила игры UNO

* [правила игры](https://www.mosigra.ru/image/data/mosigra.product.other/545/534/uno_new.pdf)
* [обзор на youtube](https://www.youtube.com/watch?v=sA5CtiLiD7M) Ru
* [youtube review En](https://www.youtube.com/watch?v=sWoSZmHsCls)


## Колода (Deck)

* Цвета: синий, зеленый, желтый, красный
* Карты с номерами от 0 до 9 и от 1 до 9 (19 карт каждого цвета) - обычные карты
* "Возьми две" - по 2 карты каждого цвета (Take 2)
* "Смени направление" - по 2 карты каждого цвета (Reverse)
* "Пропусти ход" - по 2 карты каждого цвета (Skip)
* "Дикая карта" - можно выбрать какой цвет продолжит игру, в том числе и тот, который был до этого. 
Если это первая карта игры, то цвет выбирает первый игрок.
* "Дикая карта +4" - игрок выбирает цвет, который продолжает игру, плюс следующий игрок берет 4 карты из колоды.
Её можно играть только если на руках нет подходящих **обычных карт**. 
* и т.д.

## Подготовка к игре

* Каждому игроку сдается 7 карт
* 1 карта открывается и начинает сброс.
* остальные карты кладутся в колоду в закрытую

## Цель игры

Игра продолжается до тех пор, пока один из игроков не сбросит все карты.

* Вариант 1: первый сбросивший все карты подсчитывает очки остальных. Игра идет несколько раундов, пока кто-то не наберет 500 очков. Он выиграл.
* Вариант 2: каждый получает очки от оставшихся карт на руках. Сбросивший все получает 0 очков. Игра идет до тех пор, пока кто-то не наберет 200 очков. Он проиграл.

## Ход игрока

В зависимости от цвета и действия верхней карты сброса.

* Положи одну карту из руки подходящего цвета или номера или действия.
* Если подходящей карты нет, возьми карту из колоды в закрытую.
* Если она подходит, её можно сразу же сыграть.

# Технический раздел: основные идеи реализации GUI

Приложение представляет машину состояний game.status, которая по pygame user event NEXT_PHASE вызывает 
метод game.next_phase(). Он оценивает состояние игры может перевести игру на следующую фазу.

## Состояния

* **ROUND_BEGIN** = 'Round begin' - начало хода игрока, оценивается куда можно перевести фазу - на PLAY_CARD или DRAW_CARD.
* **PLAY_CARD** = 'Choose card to play' - играется карта с руки в отбой, переходит на ROUND_END.
* **DRAW_CARD** = 'Draw card' - берется карта из колоды, тут же оценивается и переходит или на PLAY_CARD_AGAIN, либо на ROUND_END
* **PLAY_CARD_AGAIN** = 'Choose card to play again' - подумать, почему нельзя ее выбросить и заменить на состояние PLAY_CARD. Переходит на ROUND_END.
* **ROUND_END** = 'Round end' - проверка условия окончания игры (и переход на GAME_END) или смена текущего игрока, переход на ROUND_BEGIN.
* **GAME_END** = 'Game over' - конец работы. Выясняем кто победил, считаем очки, поздравляем победителя.

Переход на следующую фазу осуществляется посылкой события NEXT_PHASE. Между фазами осуществляется отрисовка измененных состояний.

Посылается событие NEXT_PHASE: если в фазе нет анимации, то сразу из game.next_phase. 
Если в фазе есть анимация (игра карт и взятие карты), то событие посылается при обработке события FLY_END.

## Анимация

Анимация полета карт сделана в классе FlyCard на основе событий таймера.

Таймер каждые TICK_MS испускает pygame user event ANIMATION. Это достигается строкой в конструкторе ViewGame:

`pygame.time.set_timer(ANIMATION, self.TICK_MS)`

В ViewGame.dispatcher, если определено поле fly, делается отрисовка смещения полета.

**Пока идет анимация, никакие другие события, кроме FLY_END и QUIT не обрабатываются.**

## Интертактивный игрок и AI (бот).

Проблема в том, что одно и то же требование выбора карты и взятие карты из колоды на очередной стадии может быть сделано по-разному:

* бот сразу берет карту или может вернуть карту, которую собирается сыграть.
* человек должен кликнуть на колоду (малоосмыслено, введено в игру в педагогических целях, чтобы было два разных типа выбора - карты и тупого клика по колоде).

Бот возвращает карту или сразу перекладывает карту из колоды на уровне game. Элементы view_game при этом сохраняют старое состояние и отрабатывают анимацию.
В конце анимации идет пересборка всего игрового стола по данным модели и перерисовка.

Интерактивный игрок переводит game в состояние wait_interactive_action. В этом состоянии все клики мыши разбираются в
ViewGame.dispatcher. Тогда ждем или клика на колоду, или клика на подходящую карту в руке. 
Если нужный клик произошел, то начинаем анимацию.



